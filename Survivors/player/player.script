-- Properties
go.property("move_speed", 250)
go.property("has_sword_ability", true)
-- The sword ability's starting cooldown in seconds.
go.property("sword_ability_base_cooldown", 3)

-- Constants
local GAME_CAMERA_URL = msg.url("main:/game_camera")
-- TODO: Dynamically get enemy URLs from messages from enemy factory
local ENEMY_URL = msg.url("main:/basic_enemy")

function init(self)
	msg.post(".", "acquire_input_focus")
	-- The direction the player is facing.
	self.direction = vmath.vector3()
	-- The sword ability's cooldown period in seconds.
	self.sword_ability_cooldown = self.sword_ability_base_cooldown
	-- The modifier for the sword ability's cooldown, if any, in seconds.
	self.sword_ability_cooldown_modifier = 0
end

function update(self, dt)
	-- Ensure diagonal movement is same speed as orthoganal movement.
	if vmath.length(self.direction) > 1 then
		self.direction = vmath.normalize(self.direction)
	end

	-- Move the player.
	local position = go.get_position()
	position = position + (self.direction * self.move_speed * dt)
	go.set_position(position)

	-- Tell game camera to update its position.
	msg.post(GAME_CAMERA_URL, "reposition", { position = position })
	msg.post(ENEMY_URL, "acquire_new_target", { target_position = position })

	-- Handle sword ability
	if self.sword_ability_cooldown <= 0 and self.has_sword_ability then
		factory.create("#sword_ability_factory", go.get_position())
		self.sword_ability_cooldown = self.sword_ability_base_cooldown + self.sword_ability_cooldown_modifier
	end

	self.sword_ability_cooldown = self.sword_ability_cooldown - dt

	-- Reset direction vector for next frame.
	self.direction = vmath.vector3()
end

function on_input(self, action_id, action)
	if action_id == hash("move_left") then
		self.direction.x = -1
	elseif action_id == hash("move_right") then
		self.direction.x = 1
	elseif action_id == hash("move_down") then
		self.direction.y = -1
	elseif action_id == hash("move_up") then
		self.direction.y = 1
	end

	-- Do not consume input.
	return false
end