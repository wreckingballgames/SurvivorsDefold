-- Properties
-- The speed at which the player moves in pixels per second.
go.property("move_speed", 250)
-- Whether or not the player has the sword ability.
go.property("has_sword_ability", true)
-- The sword ability's starting cooldown in seconds.
go.property("sword_ability_base_cooldown", 3)
-- The diameter of the collision shape (a sphere) used to detect enemies in range. Change on the collision shape to preview.
go.property("enemy_detector_diameter", 60)

-- Constants
local GAME_CAMERA_URL = msg.url("main:/game_camera")
-- TODO: Dynamically get enemy URLs from messages from enemy factory
local ENEMY_URL = msg.url("main:/basic_enemy")

local function tick_ability_cooldowns(self, dt)
	self.sword_ability_cooldown = self.sword_ability_cooldown - dt
end

local function handle_abilities(self)
	-- Sword ability
	if self.sword_ability_cooldown <= 0 and self.has_sword_ability then
		factory.create("#sword_ability_factory", go.get_position())
		self.sword_ability_cooldown = self.sword_ability_base_cooldown + self.sword_ability_cooldown_modifier
	end
end

local function move(self, dt)
	-- Ensure diagonal movement is same speed as orthoganal movement.
	if vmath.length_sqr(self.direction) > 1 then
		self.direction = vmath.normalize(self.direction)
	end

	-- Move the player.
	go.set_position(go.get_position() + (self.direction * self.move_speed * dt))

	-- Reset direction vector for next frame.
	self.direction = vmath.vector3()
end

local function announce_position()
	local position = go.get_position()
	msg.post(GAME_CAMERA_URL, "reposition", { position = position })
	msg.post(ENEMY_URL, "acquire_new_target", { target_position = position })
end

function init(self)
	msg.post(".", "acquire_input_focus")

	-- Set enemy detector's collision shape diameter.
	local sphere_data = {
		type = physics.SHAPE_TYPE_SPHERE,
		diameter = self.enemy_detector_diameter,
	}
	physics.set_shape("#enemy_detector", "sphere", sphere_data)

	-- The direction the player is facing.
	self.direction = vmath.vector3()
	-- The sword ability's cooldown period in seconds.
	self.sword_ability_cooldown = self.sword_ability_base_cooldown
	-- The modifier for the sword ability's cooldown, if any, in seconds.
	self.sword_ability_cooldown_modifier = 0
	-- The table of enemies in range. Use IDs for keys and positions for values.
	self.nearby_enemies = {}
end

function update(self, dt)
	move(self, dt)
	announce_position()

	tick_ability_cooldowns(self, dt)
	handle_abilities(self)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") then
		local other_is_enemy = message.other_group == hash("enemies")
		local other_id = message.other_id
		if other_is_enemy and message.enter then
			self.nearby_enemies.other_id = go.get_position(other_id)
			print(self.nearby_enemies)
		elseif other_is_enemy and not message.enter then
			self.nearby_enemies.other_id = nil
			print(self.nearby_enemies)
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("move_left") then
		self.direction.x = -1
	elseif action_id == hash("move_right") then
		self.direction.x = 1
	elseif action_id == hash("move_down") then
		self.direction.y = -1
	elseif action_id == hash("move_up") then
		self.direction.y = 1
	end

	-- Do not consume input.
	return false
end